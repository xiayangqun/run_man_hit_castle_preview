[1,["1dWbW45z9PtZDZDS6tToLC@6c48a","1cmAjSt7NGyJsaBfQ1CvWa"],["mainTexture","_effectAsset"],[["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Material",["_states","_defines","_props"],1,12]],[[0,0,1,2,4],[1,0,1,2,3]],[[[[0,"../matAndEffect/map/speedUp",[{"hash":318773792,"name":"../matAndEffect/map/speedUp|toon-vs:vert|toon-fs:frag","glsl4":{"vert":"#extension GL_EXT_shader_explicit_arithmetic_types_int32: require\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n      return gl_VertexIndex;\n    }\n  layout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    layout(location = 4) in u32vec4 a_joints;\n  layout(location = 5) in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      layout(location = 7) in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(set = 2, binding = 3) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(set = 2, binding = 3) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(set = 2, binding = 0) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nlayout(location = 0) out highp vec4 v_shadowPos;\nlayout(set = 0, binding = 2) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n  layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n};\nlayout(location = 1) out vec3 v_position;\nlayout(location = 2) out vec3 v_normal;\n#if USE_TEXTURE\n  layout(location = 3) out vec2 v_uv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n  #endif\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(set = 0, binding = 1) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n};\n#if CC_RECEIVE_SHADOW\n  layout(location = 0) in highp vec4 v_shadowPos;\n  layout(set = 0, binding = 2) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    lowp  vec4 cc_shadowNFLSInfo;\n    lowp  vec4 cc_shadowWHPBInfo;\n    lowp  vec4 cc_shadowLPNNInfo;\n    lowp  vec4 cc_shadowColor;\n  };\n  #if CC_RECEIVE_SHADOW\n    layout(set = 0, binding = 3) uniform sampler2D cc_shadowMap;\n    layout(set = 0, binding = 5) uniform sampler2D cc_spotLightingMap;\n    float CCGetShadowFactorHard (vec4 shadowPos) {\n      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos) {\n      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block1 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block2 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block3 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      } else {\n        block0 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n        block1 = step(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x, offsetDepth);\n        block2 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x, offsetDepth);\n        block3 = step(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x, offsetDepth);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float bias = cc_shadowWHPBInfo.w;\n      float offsetDepth = clipPos.z - bias;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block1 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block2 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block3 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block4 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block5 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block6 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block7 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block8 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      } else {\n        block0 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x, offsetDepth);\n        block1 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x, offsetDepth);\n        block2 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x, offsetDepth);\n        block3 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x, offsetDepth);\n        block4 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n        block5 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x, offsetDepth);\n        block6 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x, offsetDepth);\n        block7 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x, offsetDepth);\n        block8 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x, offsetDepth);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  #endif\n#endif\nlayout(location = 1) in vec3 v_position;\n#if USE_TEXTURE\n  layout(location = 3) in vec2 v_uv;\n  layout(set = 1, binding = 1) uniform sampler2D mainTexture;\n#endif\nlayout(location = 2) in vec3 v_normal;\nvec4 frag () {\n  vec3 V = normalize(cc_cameraPos.xyz - v_position);\n  vec3 N = normalize(v_normal);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = 0.5 * dot(N, L) + 0.5;\n  vec4 finalColor;\n  #if USE_TEXTURE\n    finalColor = texture(mainTexture, v_uv + vec2(0,cc_time.x * 2.5));\n  #endif\n  #if CC_RECEIVE_SHADOW\n        {\n          float pcf = cc_shadowWHPBInfo.z + 0.001;\n          float shadowAttenuation = 0.0;\n          float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n          vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n          vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n          if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorSoft(pos);\n          else shadowAttenuation = CCGetShadowFactorHard(pos);\n          vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n          if (cc_shadowNFLSInfo.w > 0.000001) {\n            finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n          } else {\n            finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n          }\n        }\n  #endif\n  return finalColor;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl3":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  layout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n  };\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n        ivec2 texSize = textureSize(tex, 0);\n        return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture(tex, x)),\n        decode32(texture(tex, y)),\n        decode32(texture(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    in vec4 a_joints;\n  in vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      in highp vec4 a_jointAnimInfo;\n    #endif\n    layout(std140) uniform CCSkinningTexture {\n      highp vec4 cc_jointTextureInfo;\n    };\n    layout(std140) uniform CCSkinningAnimation {\n      highp vec4 cc_jointAnimInfo;\n    };\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    layout(std140) uniform CCSkinning {\n      highp vec4 cc_joints[30 * 3];\n    };\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\n  layout(std140) uniform CCLocal {\n    highp mat4 cc_matWorld;\n    highp mat4 cc_matWorldIT;\n    highp vec4 cc_lightingMapUVParam;\n  };\n#endif\nout highp vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightView;\n  highp mat4 cc_matLightViewProj;\n  lowp  vec4 cc_shadowNFLSInfo;\n  lowp  vec4 cc_shadowWHPBInfo;\n  lowp  vec4 cc_shadowLPNNInfo;\n  lowp  vec4 cc_shadowColor;\n};\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n};\nout vec3 v_position;\nout vec3 v_normal;\n#if USE_TEXTURE\n  out vec2 v_uv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n  #endif\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_nativeSize;\n};\nlayout(std140) uniform CCCamera {\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n};\n#if CC_RECEIVE_SHADOW\n  in highp vec4 v_shadowPos;\n  layout(std140) uniform CCShadow {\n    highp mat4 cc_matLightPlaneProj;\n    highp mat4 cc_matLightView;\n    highp mat4 cc_matLightViewProj;\n    lowp  vec4 cc_shadowNFLSInfo;\n    lowp  vec4 cc_shadowWHPBInfo;\n    lowp  vec4 cc_shadowLPNNInfo;\n    lowp  vec4 cc_shadowColor;\n  };\n  #if CC_RECEIVE_SHADOW\n    uniform sampler2D cc_shadowMap;\n    uniform sampler2D cc_spotLightingMap;\n    float CCGetShadowFactorHard (vec4 shadowPos) {\n      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      } else {\n        closestDepth = texture(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos) {\n      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block1 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block2 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block3 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      } else {\n        block0 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n        block1 = step(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x, offsetDepth);\n        block2 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x, offsetDepth);\n        block3 = step(texture(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x, offsetDepth);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float bias = cc_shadowWHPBInfo.w;\n      float offsetDepth = clipPos.z - bias;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block1 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block2 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block3 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block4 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block5 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block6 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block7 = step(dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block8 = step(dot(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      } else {\n        block0 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x, offsetDepth);\n        block1 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x, offsetDepth);\n        block2 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x, offsetDepth);\n        block3 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x, offsetDepth);\n        block4 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n        block5 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x, offsetDepth);\n        block6 = step(texture(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x, offsetDepth);\n        block7 = step(texture(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x, offsetDepth);\n        block8 = step(texture(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x, offsetDepth);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  #endif\n#endif\nin vec3 v_position;\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nin vec3 v_normal;\nvec4 frag () {\n  vec3 V = normalize(cc_cameraPos.xyz - v_position);\n  vec3 N = normalize(v_normal);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = 0.5 * dot(N, L) + 0.5;\n  vec4 finalColor;\n  #if USE_TEXTURE\n    finalColor = texture(mainTexture, v_uv + vec2(0,cc_time.x * 2.5));\n  #endif\n  #if CC_RECEIVE_SHADOW\n        {\n          float pcf = cc_shadowWHPBInfo.z + 0.001;\n          float shadowAttenuation = 0.0;\n          float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n          vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n          vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n          if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorSoft(pos);\n          else shadowAttenuation = CCGetShadowFactorHard(pos);\n          vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n          if (cc_shadowNFLSInfo.w > 0.000001) {\n            finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n          } else {\n            finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n          }\n        }\n  #endif\n  return finalColor;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"},"glsl1":{"vert":"\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n      return int(a_vertexId);\n    }\n  uniform vec4 cc_displacementWeights[15];\n  uniform vec4 cc_displacementTextureInfo;\n  vec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n  }\n  vec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n  }\n  #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n        return texture2D(tex, uv);\n      }\n  #else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n      int pixelIndex = elementIndex * 4;\n      vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n      vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n      vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n      return vec4(\n        decode32(texture2D(tex, x)),\n        decode32(texture2D(tex, y)),\n        decode32(texture2D(tex, z)),\n        1.0\n      );\n    }\n  #endif\n  float getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n      return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n      return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n      return cc_displacementWeights[quot].z;\n    } else {\n      return cc_displacementWeights[quot].w;\n    }\n  }\n  vec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n  #if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n  #else\n    vec3 result = vec3(0, 0, 0);\n    int nVertices = int(cc_displacementTextureInfo.z);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n      result += (fetchVec3ArrayFromTexture(tex, nVertices * iTarget + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n  #endif\n  }\n  #if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n      return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n  #endif\n  void applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n  #if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n  #endif\n  #if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n  #endif\n  }\n  void applyMorph (inout vec4 position) {\n  #if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n  #endif\n  }\n#endif\n#if CC_USE_SKINNING\n    attribute vec4 a_joints;\n  attribute vec4 a_weights;\n  #if CC_USE_BAKED_ANIMATION\n    #if USE_INSTANCING\n      attribute highp vec4 a_jointAnimInfo;\n    #endif\n    uniform highp vec4 cc_jointTextureInfo;\n    uniform highp vec4 cc_jointAnimInfo;\n    uniform highp sampler2D cc_jointTexture;\n      #else\n    uniform highp vec4 cc_joints[90];\n  #endif\n  #if CC_USE_BAKED_ANIMATION\n    #if CC_DEVICE_SUPPORT_FLOAT_TEXTURE\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n        vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n        vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #else\n      mat4 getJointMatrix (float i) {\n              #if USE_INSTANCING\n                highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n              #else\n                highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n              #endif\n              highp float invSize = cc_jointTextureInfo.w;\n              highp float y = floor(j * invSize);\n              highp float x = floor(j - y * cc_jointTextureInfo.x);\n              y = (y + 0.5) * invSize;\n        vec4 v1 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n        );\n        vec4 v2 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n        );\n        vec4 v3 = vec4(\n          decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n          decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n        );\n        return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n      }\n    #endif\n  #else\n    mat4 getJointMatrix (float i) {\n      int idx = int(i);\n      vec4 v1 = cc_joints[idx * 3];\n      vec4 v2 = cc_joints[idx * 3 + 1];\n      vec4 v3 = cc_joints[idx * 3 + 2];\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n  mat4 skinMatrix () {\n    vec4 joints = vec4(a_joints);\n    return getJointMatrix(joints.x) * a_weights.x\n         + getJointMatrix(joints.y) * a_weights.y\n         + getJointMatrix(joints.z) * a_weights.z\n         + getJointMatrix(joints.w) * a_weights.w;\n  }\n  void CCSkin (inout vec4 position) {\n    mat4 m = skinMatrix();\n    position = m * position;\n  }\n  void CCSkin (inout StandardVertInput attr) {\n    mat4 m = skinMatrix();\n    attr.position = m * attr.position;\n    attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n    attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n  }\n#endif\nuniform highp mat4 cc_matView;\n  uniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\n  uniform highp mat4 cc_matWorld;\n  uniform highp mat4 cc_matWorldIT;\n#endif\nvarying highp vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if CC_RECEIVE_SHADOW\n  uniform sampler2D cc_shadowMap;\n  uniform sampler2D cc_spotLightingMap;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\n#if USE_TEXTURE\n  varying vec2 v_uv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n      In.position = vec4(a_position, 1.0);\n      In.normal = a_normal;\n      In.tangent = a_tangent;\n    #if CC_USE_MORPH\n      applyMorph(In);\n    #endif\n    #if CC_USE_SKINNING\n      CCSkin(In);\n    #endif\n  mat4 matWorld, matWorldIT;\n    #if USE_INSTANCING\n      matWorld = mat4(\n        vec4(a_matWorld0.xyz, 0.0),\n        vec4(a_matWorld1.xyz, 0.0),\n        vec4(a_matWorld2.xyz, 0.0),\n        vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n      );\n      matWorldIT = matWorld;\n    #elif USE_BATCHING\n      matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n      matWorldIT = matWorld;\n    #else\n      matWorld = cc_matWorld;\n      matWorldIT = cc_matWorldIT;\n    #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n  #endif\n  v_normal = (matWorldIT * vec4(In.normal, 0.0)).xyz;\n  v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }","frag":"\nprecision highp float;\nuniform highp vec4 cc_time;\nuniform highp vec4 cc_cameraPos;\n  uniform mediump vec4 cc_mainLitDir;\n#if CC_RECEIVE_SHADOW\n  varying highp vec4 v_shadowPos;\n  uniform lowp vec4 cc_shadowNFLSInfo;\n  uniform lowp vec4 cc_shadowWHPBInfo;\n  uniform lowp vec4 cc_shadowLPNNInfo;\n  uniform lowp vec4 cc_shadowColor;\n  #if CC_RECEIVE_SHADOW\n    uniform sampler2D cc_shadowMap;\n    uniform sampler2D cc_spotLightingMap;\n    float CCGetShadowFactorHard (vec4 shadowPos) {\n      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n      float shadow = 0.0;\n      float closestDepth = 0.0;\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      } else {\n        closestDepth = texture2D(cc_shadowMap, clipPos.xy).x;\n      }\n      shadow = step(closestDepth, clipPos.z- cc_shadowWHPBInfo.w);\n      return shadow;\n    }\n    float CCGetShadowFactorSoft (vec4 shadowPos) {\n      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float offsetDepth = clipPos.z - cc_shadowWHPBInfo.w;\n      vec2 oneTap = 1.0 / cc_shadowWHPBInfo.xy;\n      vec2 clipPos_offset = clipPos.xy + oneTap;\n      float block0, block1, block2, block3;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block1 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block2 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block3 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      } else {\n        block0 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n        block1 = step(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos.y)).x, offsetDepth);\n        block2 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset.y)).x, offsetDepth);\n        block3 = step(texture2D(cc_shadowMap, vec2(clipPos_offset.x, clipPos_offset.y)).x, offsetDepth);\n      }\n      float coefX   = mod(clipPos.x, oneTap.x) * cc_shadowWHPBInfo.x;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block2, block3, coefX);\n      float coefY   = mod(clipPos.y, oneTap.y) * cc_shadowWHPBInfo.y;;\n      return mix(resultX, resultY, coefY);\n    }\n    float CCGetShadowFactorSoft2X (vec4 shadowPos) {\n      vec3 clipPos = shadowPos.xyz / shadowPos.w * 0.5 + 0.5;\n      if (clipPos.x < 0.0 || clipPos.x > 1.0 ||\n          clipPos.y < 0.0 || clipPos.y > 1.0 ||\n          clipPos.z <-1.0 || clipPos.z > 1.0) { return 0.0; }\n      clipPos.xy = cc_cameraPos.w == 1.0 ? vec2(clipPos.xy.x, 1.0 - clipPos.xy.y) : clipPos.xy;\n      float bias = cc_shadowWHPBInfo.w;\n      float offsetDepth = clipPos.z - bias;\n      vec2 mapSize = cc_shadowWHPBInfo.xy;\n      vec2 oneTap = 1.0 / mapSize;\n      float clipPos_offset_L = clipPos.x - oneTap.x;\n      float clipPos_offset_R = clipPos.x + oneTap.x;\n      float clipPos_offset_U = clipPos.y - oneTap.y;\n      float clipPos_offset_D = clipPos.y + oneTap.y;\n      float block0, block1, block2, block3, block4, block5, block6, block7, block8;\n      if (cc_shadowLPNNInfo.y > 0.000001) {\n        block0 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block1 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block2 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block3 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block4 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block5 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block6 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block7 = step(dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n        block8 = step(dot(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0)), offsetDepth);\n      } else {\n        block0 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_U)).x, offsetDepth);\n        block1 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_U)).x, offsetDepth);\n        block2 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_U)).x, offsetDepth);\n        block3 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos.y)).x, offsetDepth);\n        block4 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)).x, offsetDepth);\n        block5 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos.y)).x, offsetDepth);\n        block6 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_L, clipPos_offset_D)).x, offsetDepth);\n        block7 = step(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos_offset_D)).x, offsetDepth);\n        block8 = step(texture2D(cc_shadowMap, vec2(clipPos_offset_R, clipPos_offset_D)).x, offsetDepth);\n      }\n      float coefX = mod(clipPos.x, oneTap.x) * mapSize.x;\n      float coefY = mod(clipPos.y, oneTap.y) * mapSize.y;\n      float shadow = 0.0;\n      float resultX = mix(block0, block1, coefX);\n      float resultY = mix(block3, block4, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block1, block2, coefX);\n      resultY = mix(block4, block5, coefX);\n      shadow += mix(resultX , resultY, coefY);\n      resultX = mix(block3, block4, coefX);\n      resultY = mix(block6, block7, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      resultX = mix(block4, block5, coefX);\n      resultY = mix(block7, block8, coefX);\n      shadow += mix(resultX, resultY, coefY);\n      return shadow * 0.25;\n    }\n  #endif\n#endif\nvarying vec3 v_position;\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nvarying vec3 v_normal;\nvec4 frag () {\n  vec3 V = normalize(cc_cameraPos.xyz - v_position);\n  vec3 N = normalize(v_normal);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  float NL = 0.5 * dot(N, L) + 0.5;\n  vec4 finalColor;\n  #if USE_TEXTURE\n    finalColor = texture2D(mainTexture, v_uv + vec2(0,cc_time.x * 2.5));\n  #endif\n  #if CC_RECEIVE_SHADOW\n        {\n          float pcf = cc_shadowWHPBInfo.z + 0.001;\n          float shadowAttenuation = 0.0;\n          float cosAngle = clamp(1.0 - dot(N, cc_mainLitDir.xyz), 0.0, 1.0);\n          vec3 projWorldPos = v_shadowPos.xyz + cosAngle * cc_shadowLPNNInfo.z * N;\n          vec4 pos = vec4(projWorldPos.xyz, v_shadowPos.w);\n          if (pcf > 2.0) shadowAttenuation = CCGetShadowFactorSoft2X(pos);\n          else if (pcf > 1.0) shadowAttenuation = CCGetShadowFactorSoft(pos);\n          else shadowAttenuation = CCGetShadowFactorHard(pos);\n          vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor.rgb * (1.0 - cc_shadowColor.a);\n          if (cc_shadowNFLSInfo.w > 0.000001) {\n            finalColor.rgb = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n          } else {\n            finalColor.rgb = shadowColor.rgb * shadowAttenuation * NL + finalColor.rgb * (1.0 - shadowAttenuation * NL);\n          }\n        }\n  #endif\n  return finalColor;\n}\nvoid main() { gl_FragColor = frag(); }"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]},{"name":"CCCamera","defines":[]},{"name":"CCShadow","defines":[]}],"samplerTextures":[{"name":"cc_shadowMap","defines":["CC_RECEIVE_SHADOW"]},{"name":"cc_spotLightingMap","defines":["CC_RECEIVE_SHADOW"]}]},"locals":{"blocks":[{"name":"CCMorph","defines":["CC_USE_MORPH"]},{"name":"CCSkinningTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinningAnimation","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]},{"name":"CCSkinning","defines":["CC_USE_SKINNING","!CC_USE_BAKED_ANIMATION"]},{"name":"CCLocalBatched","defines":["!USE_INSTANCING","USE_BATCHING"]},{"name":"CCLocal","defines":["!USE_INSTANCING","!USE_BATCHING"]}],"samplerTextures":[{"name":"cc_PositionDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_POSITION"]},{"name":"cc_NormalDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_NORMAL"]},{"name":"cc_TangentDisplacements","defines":["CC_USE_MORPH","CC_MORPH_TARGET_HAS_TANGENT"]},{"name":"cc_jointTexture","defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION"]}]},"statistics":{"CC_EFFECT_USED_VERTEX_UNIFORM_VECTORS":211,"CC_EFFECT_USED_FRAGMENT_UNIFORM_VECTORS":54}},"defines":[{"name":"CC_USE_MORPH","type":"boolean","defines":[]},{"name":"CC_MORPH_TARGET_COUNT","type":"number","defines":["CC_USE_MORPH"],"range":[2,8]},{"name":"CC_MORPH_PRECOMPUTED","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_POSITION","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_NORMAL","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_MORPH_TARGET_HAS_TANGENT","type":"boolean","defines":["CC_USE_MORPH"]},{"name":"CC_USE_SKINNING","type":"boolean","defines":[]},{"name":"CC_USE_BAKED_ANIMATION","type":"boolean","defines":["CC_USE_SKINNING"]},{"name":"USE_INSTANCING","type":"boolean","defines":[],"editor":{"elevated":true}},{"name":"USE_BATCHING","type":"boolean","defines":["!USE_INSTANCING"],"editor":{"elevated":true}},{"name":"USE_LIGHTMAP","type":"boolean","defines":["USE_INSTANCING"]},{"name":"CC_RECEIVE_SHADOW","type":"boolean","defines":[]},{"name":"USE_TEXTURE","type":"boolean","defines":[]}],"blocks":[{"name":"Constants","stageFlags":17,"binding":0,"members":[{"name":"tilingOffset","type":16,"count":1}],"defines":[]}],"samplerTextures":[{"name":"mainTexture","type":28,"count":1,"stageFlags":16,"binding":1,"defines":["USE_TEXTURE"]}],"attributes":[{"name":"a_position","type":15,"count":1,"stageFlags":1,"format":32,"location":0,"defines":[]},{"name":"a_normal","type":15,"count":1,"stageFlags":1,"format":32,"location":1,"defines":[]},{"name":"a_texCoord","type":14,"count":1,"stageFlags":1,"format":21,"location":2,"defines":[]},{"name":"a_tangent","type":16,"count":1,"stageFlags":1,"format":44,"location":3,"defines":[]},{"name":"a_vertexId","type":13,"count":1,"stageFlags":1,"format":11,"location":6,"defines":["CC_USE_MORPH"]},{"name":"a_joints","type":"u32vec4","count":1,"stageFlags":1,"location":4,"defines":["CC_USE_SKINNING"]},{"name":"a_weights","type":16,"count":1,"stageFlags":1,"format":44,"location":5,"defines":["CC_USE_SKINNING"]},{"name":"a_jointAnimInfo","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":7,"defines":["CC_USE_SKINNING","CC_USE_BAKED_ANIMATION","USE_INSTANCING"]},{"name":"a_matWorld0","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":8,"defines":["USE_INSTANCING"]},{"name":"a_matWorld1","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":9,"defines":["USE_INSTANCING"]},{"name":"a_matWorld2","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":10,"defines":["USE_INSTANCING"]},{"name":"a_lightingMapUVParam","type":16,"count":1,"stageFlags":1,"format":44,"isInstanced":true,"location":11,"defines":["USE_INSTANCING","USE_LIGHTMAP"]},{"name":"a_dyn_batch_id","type":13,"count":1,"stageFlags":1,"format":11,"location":12,"defines":["!USE_INSTANCING","USE_BATCHING"]}],"varyings":[{"name":"v_shadowPos","type":16,"count":1,"stageFlags":1,"location":0,"defines":[]},{"name":"v_position","type":15,"count":1,"stageFlags":1,"location":1,"defines":[]},{"name":"v_normal","type":15,"count":1,"stageFlags":1,"location":2,"defines":[]},{"name":"v_uv","type":14,"count":1,"stageFlags":1,"location":3,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"../matAndEffect/map/speedUp|toon-vs:vert|toon-fs:frag","properties":{"mainTexture":{"value":"grey","type":28},"tilingOffset":{"type":16,"value":[1,1,0,0]}}}]}]]],0,0,[],[],[]],[[[1,[{"rasterizerState":{},"depthStencilState":{},"blendState":{"targets":[{}]}}],[{"USE_TEXTURE":true}],[[[{},"mainTexture",6,0]],11]]],0,0,[0,0],[0,1],[0,1]]]]
